import pygame
import cv2
import sys
import random
import time
import RPi.GPIO as GPIO  # Importa la biblioteca de GPIO

# Configurar los pines GPIO
GPIO.setmode(GPIO.BCM)
GPIO.setup(17, GPIO.IN, pull_up_down=GPIO.PUD_UP)
GPIO.setup(27, GPIO.IN, pull_up_down=GPIO.PUD_UP)
GPIO.setup(22, GPIO.IN, pull_up_down=GPIO.PUD_UP)
GPIO.setup(5, GPIO.IN, pull_up_down=GPIO.PUD_UP)
GPIO.setup(6, GPIO.IN, pull_up_down=GPIO.PUD_UP)
GPIO.setup(13, GPIO.IN, pull_up_down=GPIO.PUD_UP)

# Inicializar Pygame
pygame.init()

# Tamaño de la pantalla
screen_width = 800
screen_height = 600
screen = pygame.display.set_mode((screen_width, screen_height))

# Título de la ventana
pygame.display.set_caption("Focusboard")
icon_image = pygame.image.load("icon1.png")
pygame.display.set_icon(icon_image)

# Colores
WHITE = (255, 255, 255)
BLUE = (0, 0, 255)
RED = (255, 0, 0)
GREEN = (0, 255, 0)
YELLOW = (255, 255, 0)
ORANGE = (255, 165, 0)
PURPLE = (128, 0, 128)

# Mapear botones GPIO a colores
gpio_key_map = {
    17: ("Rojo", RED),
    27: ("Verde", GREEN),
    22: ("Azul", BLUE),
    5: ("Amarillo", YELLOW),
    6: ("Naranja", ORANGE),
    13: ("Morado", PURPLE)
}

# Configuración de fuente
font = pygame.font.Font(None, 40)

# Variables del juego
score = 0
running = True
difficulty = "Medio"
difficulty_speed_map = {
    "Facil": 4,    # Más tiempo para presionar
    "Medio": 3,    # Tiempo moderado
    "Dificil": 2   # Menos tiempo para presionar
}

# Función para mostrar texto en pantalla
def display_message(message, color=WHITE):
    screen.fill((0, 0, 0))
    text = font.render(message, True, color)
    screen.blit(text, (screen_width // 2 - text.get_width() // 2, screen_height // 2 - text.get_height() // 2))
    pygame.display.flip()

# Función para mostrar temporizador y contador de juego
def display_timers(remaining_time, elapsed_time):
    screen.fill((0, 0, 0), (0, 0, screen_width, 50))  # Limpiar parte superior de la pantalla para temporizadores
    timer_text = font.render(f"Tiempo restante: {remaining_time:.1f} s", True, WHITE)
    elapsed_text = font.render(f"Tiempo total: {elapsed_time:.1f} s", True, WHITE)
    
    # Mostrar temporizador y tiempo transcurrido
    screen.blit(timer_text, (20, 10))
    screen.blit(elapsed_text, (screen_width - 250, 10))
    pygame.display.update()

# Función principal del juego de teclas
def game_loop(song):
    global score, running, difficulty
    score = 0
    game_start_time = time.time()
    
    # Reproducir la canción seleccionada
    pygame.mixer.music.load(song)
    pygame.mixer.music.play(-1)
    
    display_message("Presiona Enter para comenzar.")
    
    # Espera hasta que el jugador presione Enter
    while True:
        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                running = False
                return
            elif event.type == pygame.KEYDOWN and event.key == pygame.K_RETURN:
                break
        else:
            continue
        break

    # Juego activo
    while running:
        gpio_pin, (color_name, color) = random.choice(list(gpio_key_map.items()))
        display_message(f"Presiona el botón {color_name}", color)
        button_start_time = time.time()
        waiting_for_input = True

        # Juego activo para cada ronda
        while waiting_for_input:
            for event in pygame.event.get():
                if event.type == pygame.QUIT:
                    running = False
                    return

            # Actualizar fondo con el color del botón
            screen.fill(color)

            # Calcular el tiempo restante y tiempo total
            elapsed_time = time.time() - game_start_time
            remaining_time = difficulty_speed_map[difficulty] - (time.time() - button_start_time)

            # Mostrar temporizador y contador
            display_timers(remaining_time, elapsed_time)

            # Verificar si el tiempo se ha agotado
            if remaining_time <= 0:
                display_message("¡Tiempo agotado!", WHITE)
                pygame.time.delay(1000)
                waiting_for_input = False
                break

            # Verificar si se presionó un botón físico
            for pin, (btn_color, _) in gpio_key_map.items():
                if GPIO.input(pin) == GPIO.LOW:  # Si se presiona el botón
                    if pin == gpio_pin:
                        score += 1
                        display_message(f"¡Correcto! Puntuación: {score}", WHITE)
                        pygame.time.delay(1000)
                        waiting_for_input = False
                        break
                    else:
                        display_message("Botón incorrecto. Inténtalo de nuevo.", WHITE)
                        pygame.time.delay(1000)
                        waiting_for_input = False
                        break

        pygame.display.flip()

    # Detener la música cuando el juego termine
    pygame.mixer.music.stop()

# Función para manejar las dificultades seleccionadas
def handle_difficulty_selection(selected_difficulty):
    global difficulty
    difficulty = selected_difficulty
    display_message(f"Dificultad seleccionada: {difficulty}")
    pygame.time.delay(1000)

# Iniciar el menú principal
game_loop("cancion1.mp3")  # Puedes cambiar el archivo de música

# Limpiar los pines GPIO al salir
GPIO.cleanup()
pygame.quit()
sys.exit()
