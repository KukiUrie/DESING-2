import pygame
import sys
import random
import time
import RPi.GPIO as GPIO
from dataclasses import dataclass
from typing import List, Dict, Optional
import math

@dataclass
class Song:
    filename: str
    name: str
    bpm: int
    duration: float
    background_color: tuple = (0, 0, 0)

@dataclass
class Difficulty:
    name: str
    speed: float
    score_multiplier: float
    timing_window: float
    note_speed: int

# Constantes de colores
COLORS = {
    'BLACK': (0, 0, 0),
    'WHITE': (255, 255, 255),
    'BLUE': (0, 100, 255),
    'RED': (255, 50, 50),
    'GREEN': (50, 255, 50),
    'YELLOW': (255, 255, 50),
    'PURPLE': (150, 50, 255),
    'CYAN': (50, 255, 255)
}

class ParticleEffect:
    def __init__(self, x, y, color):
        self.x = x
        self.y = y
        self.particles = []
        self.color = color
        self.lifetime = 30  # Aseguramos que se defina correctamente
        self.create_particles()

    def create_particles(self):
        """Crea las partículas individuales."""
        for _ in range(10):
            angle = random.uniform(0, math.pi * 2)
            speed = random.uniform(2, 5)
            self.particles.append({
                'x': self.x,
                'y': self.y,
                'dx': math.cos(angle) * speed,
                'dy': math.sin(angle) * speed,
                'lifetime': self.lifetime  # Correctamente asignado
            })

    def update(self):
        """Actualiza las posiciones y tiempos de vida de las partículas."""
        for particle in self.particles:
            particle['x'] += particle['dx']
            particle['y'] += particle['dy']
            particle['lifetime'] -= 1

    def draw(self, screen):
        """Dibuja las partículas en la pantalla."""
        for particle in self.particles:
            if particle['lifetime'] > 0:
                alpha = int((particle['lifetime'] / self.lifetime) * 255)
                color = (*self.color, alpha)
                surf = pygame.Surface((4, 4), pygame.SRCALPHA)
                pygame.draw.circle(surf, color, (2, 2), 2)
                screen.blit(surf, (particle['x'] - 2, particle['y'] - 2))

class RhythmGame:
    def __init__(self):
        # Inicialización de GPIO
        GPIO.setmode(GPIO.BCM)
        self.buttons = [17, 27, 22, 5, 6, 13]
        self._setup_gpio()

        # Inicialización de Pygame
        pygame.init()
        pygame.mixer.init()
        pygame.font.init()

        # Configuración de pantalla
        self.screen_width = 800
        self.screen_height = 600
        self.screen = pygame.display.set_mode((self.screen_width, self.screen_height))
        pygame.display.set_caption("Rhythm Master")

        # Fuentes
        self.font_large = pygame.font.Font(None, 74)
        self.font_medium = pygame.font.Font(None, 48)
        self.font_small = pygame.font.Font(None, 36)

        # Canciones
        self.songs = [
            Song("cancion1.mp3", "Melodía Suave", 120, 180, COLORS['BLUE']),
            Song("cancion2.mp3", "Ritmo Latino", 140, 200, COLORS['PURPLE']),
            Song("cancion3.mp3", "Rock Intenso", 160, 220, COLORS['RED'])
        ]

        # Dificultades
        self.difficulties = [
            Difficulty("Fácil", 4.0, 1.0, 1.0, 3),
            Difficulty("Medio", 3.0, 1.5, 0.8, 5),
            Difficulty("Difícil", 2.0, 2.0, 0.5, 7)
        ]

        # Estado del juego
        self.score = 0
        self.combo = 0
        self.max_combo = 0
        self.perfect_hits = 0
        self.good_hits = 0
        self.misses = 0
        self.particle_effects = []
        self.running = True
        self.notes = []
        self.button_lights = [{'active': False, 'timer': 0} for _ in self.buttons]
        self.lane_width = self.screen_width / len(self.buttons)

    def _setup_gpio(self):
        """Configura los pines GPIO."""
        for pin in self.buttons:
            GPIO.setup(pin, GPIO.IN, pull_up_down=GPIO.PUD_UP)

    def draw_gameplay(self):
        """Dibuja todos los elementos del juego."""
        self.screen.fill(COLORS['BLACK'])
        for effect in self.particle_effects[:]:
            effect.update()
            effect.draw(self.screen)
            if all(p['lifetime'] <= 0 for p in effect.particles):
                self.particle_effects.remove(effect)

        pygame.display.flip()

    def handle_input(self):
        """Maneja la entrada de los botones."""
        for i, pin in enumerate(self.buttons):
            if GPIO.input(pin) == GPIO.LOW:
                self.button_lights[i]['active'] = True
                self.button_lights[i]['timer'] = 10

                # Buscar la nota más cercana
                closest_note = min(
                    (note for note in self.notes if note['lane'] == i and not note['active']),
                    key=lambda note: abs(note['y'] - (self.screen_height - 100)),
                    default=None
                )

                if closest_note:
                    closest_note['active'] = True
                    self.handle_hit(closest_note)

    def handle_hit(self, note):
        """Maneja un acierto."""
        self.perfect_hits += 1
        self.score += 100 * self.combo
        self.combo += 1

    def show_results(self):
        """Muestra los resultados al final del juego."""
        print(f"Puntuación final: {self.score}")
        print(f"Perfect Hits: {self.perfect_hits}")

    def run(self):
        """Bucle principal del juego."""
        try:
            while self.running:
                self.handle_input()
                self.draw_gameplay()
        except KeyboardInterrupt:
            print("Juego terminado.")
        finally:
            self.cleanup()

    def cleanup(self):
        """Limpia los recursos."""
        GPIO.cleanup()
        pygame.quit()
        sys.exit()

if __name__ == "__main__":
    game = RhythmGame()
    game.run()
