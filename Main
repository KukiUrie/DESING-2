import pygame
import sys
import random
import time
import RPi.GPIO as GPIO
from dataclasses import dataclass
from typing import List

@dataclass
class Song:
    filename: str
    name: str
    bpm: int
    duration: float

@dataclass
class Difficulty:
    name: str
    speed: float
    score_multiplier: float
    timing_window: float  # Ventana de tiempo para acertar las notas

@dataclass
class Note:
    time: float  # Tiempo en segundos en el que debe ser presionada
    button: int  # Índice del botón que debe ser presionado

class RhythmGame:
    def __init__(self):
        GPIO.setmode(GPIO.BCM)
        self.buttons = [17, 27, 22, 5, 6, 13]
        self._setup_gpio()

        pygame.mixer.init()

        self.songs = [
            Song("cancion1.mp3", "Melodía Suave", 120, 180),
            Song("cancion2.mp3", "Ritmo Latino", 140, 200),
            Song("cancion3.mp3", "Rock Intenso", 160, 220)
        ]

        self.difficulties = [
            Difficulty("Fácil", 4.0, 1.0, 1.0),
            Difficulty("Medio", 3.0, 1.5, 0.8),
            Difficulty("Difícil", 2.0, 2.0, 0.5)
        ]

        self.current_song = None
        self.current_difficulty = None
        self.score = 0
        self.combo = 0
        self.max_combo = 0
        self.perfect_hits = 0
        self.misses = 0
        self.running = True
        self.notes = []

    def _setup_gpio(self):
        for pin in self.buttons:
            GPIO.setup(pin, GPIO.IN, pull_up_down=GPIO.PUD_UP)
        print("Pines GPIO configurados correctamente.")

    def generate_notes(self):
        """Genera las notas de la canción en función del BPM."""
        bpm_interval = 60 / self.current_song.bpm  # Intervalo en segundos entre notas
        total_notes = int(self.current_song.duration / bpm_interval)

        self.notes = [
            Note(time=i * bpm_interval, button=random.randint(0, len(self.buttons) - 1))
            for i in range(total_notes)
        ]

    def wait_for_button_press(self):
        while True:
            for i, pin in enumerate(self.buttons):
                if GPIO.input(pin) == GPIO.LOW:
                    time.sleep(0.2)  # Debounce
                    return i

    def select_song(self):
        print("Selecciona una canción:")
        for i, song in enumerate(self.songs):
            print(f"{i + 1}: {song.name}")

        selected_index = self.wait_for_button_press()
        self.current_song = self.songs[selected_index]
        print(f"Has seleccionado: {self.current_song.name}")

    def select_difficulty(self):
        print("Selecciona la dificultad:")
        for i, diff in enumerate(self.difficulties):
            print(f"{i + 1}: {diff.name}")

        selected_index = self.wait_for_button_press()
        self.current_difficulty = self.difficulties[selected_index]
        print(f"Has seleccionado: {self.current_difficulty.name}")

    def play_music(self):
        try:
            pygame.mixer.music.load(self.current_song.filename)
            pygame.mixer.music.play()
            print(f"Reproduciendo: {self.current_song.name}")
        except pygame.error as e:
            print(f"Error: No se pudo cargar la canción {self.current_song.filename}: {e}")
            sys.exit()

    def gameplay_loop(self):
        self.generate_notes()  # Generar las notas antes de empezar
        start_time = time.time()

        print("¡Inicia el juego! Presiona los botones al ritmo correcto.")

        note_index = 0  # Índice de la siguiente nota a verificar

        while pygame.mixer.music.get_busy():
            current_time = time.time() - start_time

            # Verificar si la nota actual ha pasado su tiempo de activación
            if note_index < len(self.notes) and current_time >= self.notes[note_index].time:
                print(f"Nota disponible: Botón {self.notes[note_index].button + 1}")

                button_pressed = self.wait_for_button_press()

                if button_pressed == self.notes[note_index].button:
                    self.perfect_hits += 1
                    self.score += 100 * self.current_difficulty.score_multiplier
                    self.combo += 1
                    self.max_combo = max(self.max_combo, self.combo)
                    print(f"¡Perfect! Combo: {self.combo}")
                else:
                    self.misses += 1
                    self.combo = 0
                    print("¡Fallo!")

                note_index += 1  # Pasar a la siguiente nota

        print("¡La canción ha terminado!")
        self.show_results()

    def show_results(self):
        print("\n--- Resultados ---")
        print(f"Puntuación final: {self.score}")
        print(f"Combo máximo: {self.max_combo}")
        print(f"Perfect: {self.perfect_hits}")
        print(f"Fallas: {self.misses}")
        print("------------------")

    def run(self):
        try:
            while self.running:
                self.select_song()
                self.select_difficulty()

                print("Iniciando en 3...")
                time.sleep(1)
                print("2...")
                time.sleep(1)
                print("1...")
                time.sleep(1)

                self.play_music()
                self.gameplay_loop()

                print("¿Quieres jugar de nuevo? Presiona un botón (0 = Sí, 1 = No).")
                play_again = self.wait_for_button_press()
                if play_again != 0:
                    self.running = False

        except KeyboardInterrupt:
            print("\nJuego terminado por el usuario")
        finally:
            self.cleanup()

    def cleanup(self):
        GPIO.cleanup()
        pygame.mixer.quit()
        sys.exit()

if __name__ == "__main__":
    game = RhythmGame()
    game.run()
