import pygame
import sys
import random
import time
import RPi.GPIO as GPIO
from dataclasses import dataclass
from typing import List

@dataclass
class Song:
    filename: str
    name: str
    bpm: int
    duration: float

@dataclass
class Difficulty:
    name: str
    speed: float
    score_multiplier: float
    timing_window: float  # Ventana de tiempo para acertar las notas

class RhythmGame:
    def __init__(self):
        # Inicialización de GPIO
        GPIO.setmode(GPIO.BCM)
        self.buttons = [17, 27, 22, 5, 6, 13]  # Pines GPIO para los botones
        self._setup_gpio()

        # Inicialización de Pygame
        pygame.mixer.init()

        # Definición de canciones y dificultades
        self.songs = [
            Song("cancion1.mp3", "Melodía Suave", 120, 180),
            Song("cancion2.mp3", "Ritmo Latino", 140, 200),
            Song("cancion3.mp3", "Rock Intenso", 160, 220)
        ]

        self.difficulties = [
            Difficulty("Fácil", 4.0, 1.0, 1.0),
            Difficulty("Medio", 3.0, 1.5, 0.8),
            Difficulty("Difícil", 2.0, 2.0, 0.5)
        ]

        # Estado del juego
        self.current_song = None
        self.current_difficulty = None
        self.score = 0
        self.combo = 0
        self.max_combo = 0
        self.perfect_hits = 0
        self.misses = 0
        self.running = True

    def _setup_gpio(self):
        """Configura los pines GPIO para los botones."""
        for pin in self.buttons:
            GPIO.setup(pin, GPIO.IN, pull_up_down=GPIO.PUD_UP)
        print("Pines GPIO configurados correctamente.")

    def wait_for_button_press(self):
        """Espera hasta que se presione un botón y devuelve su índice."""
        print("Esperando la selección de un botón...")
        while True:
            for i, pin in enumerate(self.buttons):
                if GPIO.input(pin) == GPIO.LOW:
                    time.sleep(0.2)  # Debounce
                    print(f"Botón {i + 1} presionado.")
                    return i

    def select_song(self):
        """Selecciona una canción usando los botones."""
        print("Selecciona una canción:")
        for i, song in enumerate(self.songs):
            print(f"{i + 1}: {song.name}")

        selected_index = self.wait_for_button_press()
        self.current_song = self.songs[selected_index]
        print(f"Has seleccionado: {self.current_song.name}")

    def select_difficulty(self):
        """Selecciona una dificultad usando los botones."""
        print("Selecciona la dificultad:")
        for i, diff in enumerate(self.difficulties):
            print(f"{i + 1}: {diff.name}")

        selected_index = self.wait_for_button_press()
        self.current_difficulty = self.difficulties[selected_index]
        print(f"Has seleccionado: {self.current_difficulty.name}")

    def play_music(self):
        """Inicia la música seleccionada."""
        try:
            pygame.mixer.music.load(self.current_song.filename)
            pygame.mixer.music.play()
            print(f"Reproduciendo: {self.current_song.name}")
        except pygame.error as e:
            print(f"Error: No se pudo cargar la canción {self.current_song.filename}: {e}")
            sys.exit()

    def gameplay_loop(self):
        """Bucle principal del juego sincronizado con la música."""
        bpm_interval = 60 / self.current_song.bpm  # Intervalo entre pulsaciones correctas
        last_press_time = time.time()

        print("¡Inicia el juego! Presiona los botones al ritmo correcto.")

        while pygame.mixer.music.get_busy():  # Mientras la canción esté reproduciéndose
            for i, pin in enumerate(self.buttons):
                if GPIO.input(pin) == GPIO.LOW:
                    current_time = time.time()
                    time_diff = current_time - last_press_time

                    # Verificar si la pulsación fue en el tiempo correcto
                    if abs(time_diff - bpm_interval) < self.current_difficulty.timing_window:
                        self.perfect_hits += 1
                        self.score += 100 * self.current_difficulty.score_multiplier
                        self.combo += 1
                        self.max_combo = max(self.max_combo, self.combo)
                        print(f"¡Perfect! Combo: {self.combo}")
                    else:
                        self.misses += 1
                        self.combo = 0
                        print("¡Fallo!")

                    last_press_time = current_time  # Actualizar tiempo de la última pulsación
                    time.sleep(0.2)  # Debounce

        print("¡La canción ha terminado!")
        self.show_results()

    def show_results(self):
        """Muestra los resultados al final del juego."""
        print("\n--- Resultados ---")
        print(f"Puntuación final: {self.score}")
        print(f"Combo máximo: {self.max_combo}")
        print(f"Perfect: {self.perfect_hits}")
        print(f"Fallas: {self.misses}")
        print("------------------")

    def run(self):
        """Ejecuta el flujo principal del juego."""
        try:
            while self.running:
                self.select_song()
                self.select_difficulty()

                print("Iniciando en 3...")
                time.sleep(1)
                print("2...")
                time.sleep(1)
                print("1...")
                time.sleep(1)

                self.play_music()
                self.gameplay_loop()

                print("¿Quieres jugar de nuevo? Presiona un botón (0 = Sí, 1 = No).")
                play_again = self.wait_for_button_press()
                if play_again != 0:
                    self.running = False

        except KeyboardInterrupt:
            print("\nJuego terminado por el usuario")
        finally:
            self.cleanup()

    def cleanup(self):
        """Limpia los recursos y cierra el juego."""
        GPIO.cleanup()
        pygame.mixer.quit()
        sys.exit()

if __name__ == "__main__":
    game = RhythmGame()
    game.run()
